package com.fudan.productsupport.service.impl;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import com.fudan.productsupport.entity.mongodb.ClassificationRelationshipEntity;
import com.fudan.productsupport.entity.mongodb.ERModuleEntity;
import com.fudan.productsupport.service.ClassificationRelationshipService;
import com.fudan.productsupport.service.ClassificationService;
import com.fudan.productsupport.service.ERModuleService;
import com.fudan.productsupport.service.VulnerabilityAnnotationService;
import com.fudan.productsupport.utils.NebularGraphUtil;
import com.vesoft.nebula.client.graph.data.Node;
import com.vesoft.nebula.client.graph.data.Relationship;
import com.vesoft.nebula.client.graph.data.ValueWrapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.annotation.Resource;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;

/**
 * @ClassName VulnerabilityAnnotationServiceImpl
 * Description TODO
 * @Author WillemGavin
 * @Date 2022/5/12 21:36
 * Version 0.0.1
 */

@Service
@ResponseBody
@Slf4j
public class VulnerabilityAnnotationServiceImpl implements VulnerabilityAnnotationService {

    @Resource
    private NebularGraphUtil nebularGraphUtil;
    @Resource
    private ERModuleService erModuleService;
    @Resource
    private ClassificationRelationshipService classificationRelationshipService;

    @Value("5")
    private int vulnerabilityStep = 5;
    /**
     * 追踪漏洞影响范围
     * @param vulnerabilityId
     * @param targetId
     */
    @Override
    public void tracking(String vulnerabilityId, String targetId) {
        // 获取子图
        List<ValueWrapper> pathList = nebularGraphUtil.getSubGraph(targetId, "Include", vulnerabilityStep, false);
        // 先遍历所有的路径
        for(int i = 0; i < pathList.size(); i++){
            try {
                List<Node> nodeList = pathList.get(i).asPath().getNodes();
                // 遍历路径中所有的节点
                for(int j = 0; j < nodeList.size(); j++){
                    Node node = nodeList.get(j);
                    // 构建漏洞影响边
                    affectedMark(vulnerabilityId, node, "affected", j);
                    if(isBorder(node)){
                        // 当已经到边界
                        break;
                    }
                }
            } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 删除漏洞信息
     * @param ids
     */
    @Override
    public void delete(List<String> ids) {
        log.info("删除漏洞节点：" + ids);
        // nebula Graph 删除点之前会把边也删除
        nebularGraphUtil.deleteVertiex(ids);
    }

    /**
     * 构建受影响节点和漏洞之间的边
     * @param sourceId
     * @param node
     * @param edgeType
     * @param distance
     */
    private void affectedMark(String sourceId, Node node, String edgeType, int distance){
        // 获取 affected 边的ERModule
        ERModuleEntity affectedModule = erModuleService.queryByName(edgeType).get(0);
        JSONObject edgeData = new JSONObject();
        edgeData.put("from", sourceId);
        String targetId = node.getId().toString();
        targetId = targetId.substring(1, targetId.length() - 1);
        edgeData.put("to", targetId);
        edgeData.put("distance", distance);
        JSONArray jsonArray = new JSONArray();
        jsonArray.add(edgeData);
        // 创建本漏洞到直接影响节点的边
        nebularGraphUtil.insertEdge(affectedModule, jsonArray);
    }

    /**
     *
     * @param node
     * @return
     */
    private boolean isBorder(Node node){
        // 判断是否已到边界
        ClassificationRelationshipEntity classificationRelationshipEntity = new ClassificationRelationshipEntity("RootModule");
        List<ClassificationRelationshipEntity> classifications = classificationRelationshipService.query(classificationRelationshipEntity);
        for(ClassificationRelationshipEntity c: classifications){
            if(node.hasLabel(c.getTagName())){
                return true;
            }
        }
        return false;
    }
}
